# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vd0dz5M7Cl_IMNqSDzQEYwY30hdxrsvK
"""

#!pip3 install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118

import cv2
import numpy as np
import os
import matplotlib.pyplot as plt
import tensorflow as tf
import zipfile
import pandas as pd
import torch
import torch.nn as nn
import torch.nn.functional as F
import sys

!unzip melanoma_cancer_dataset_zip.zip

# Loading Data
# Datase from Kaggle

benign_train = "/content/melanoma_cancer_dataset/train/benign"

mal_train = "/content/melanoma_cancer_dataset/train/malignant"

benign_test = "/content/melanoma_cancer_dataset/test/benign"

mal_test = "/content/melanoma_cancer_dataset/test/malignant"

# Coverting the images into arrays

btrain_data = []
mtrain_data = []


btest_data = []
mtest_data = []

#begign training data

for filename in os.listdir(benign_train):



      path = os.path.join(benign_train, filename)

      img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)

      # Checking if the image was loaded successfully
      if img is not None:
          img = cv2.resize(img, (100,100))

          img_array = np.array(img)

          #[1,0]- begign, [0,1] - malignant
          btrain_data.append([img_array, np.array([1,0])])
      else:
          print(f"Failed to load image: {path}")

# Malignant training data

for filename in os.listdir(mal_train):



      path = os.path.join(mal_train, filename)

      img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)

      # Checking if the image was loaded successfully
      if img is not None:
          img = cv2.resize(img, (100,100))


          img_array = np.array(img)

          #[1,0]- begign, [0,1] - malignant
          mtrain_data.append([img_array, np.array([0,1])])
      else:
          print(f"Failed to load image: {path}")

# Begign test data

for filename in os.listdir(benign_test):



      path = os.path.join(benign_test, filename)

      img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)

      # Checking if the image was loaded successfully
      if img is not None:
          img = cv2.resize(img, (100,100))

          img_array = np.array(img)

          #[1,0]- begign, [0,1] - malignant
          btest_data.append([img_array, np.array([1,0])])
      else:
          print(f"Failed to load image: {path}")

# Malignant test data

for filename in os.listdir(mal_test):



      path = os.path.join(mal_test, filename)

      img = cv2.imread(path, cv2.IMREAD_GRAYSCALE)

      # Checking if the image was loaded successfully
      if img is not None:

          img = cv2.resize(img, (100,100))

          img_array = np.array(img)

          #[1,0]- begign, [0,1] - malignant
          mtest_data.append([img_array, np.array([0,1])])
      else:
          print(f"Failed to load image: {path}")

print(f"Benign training count: {len(btrain_data)}")
print(f"Malignant training count: {len(mtrain_data)}")
print(f"Benign testing count: {len(btest_data)}")
print(f"Malignant testing count: {len(mtest_data)}")

# Making sure number of begign and malignant samples are the same
btrain_data = btrain_data[0:len(mtrain_data)]

#making the train and test datasets

train_data = btrain_data + mtrain_data
np.random.shuffle(train_data)

print(len(train_data))


test_data = btest_data + mtest_data
np.random.shuffle(test_data)

print(len(test_data))

test_data[2]

class Net(nn.Module):

  def __init__(self):
    super().__init__()

    self.conv1 = nn.Conv2d(1,32, kernel_size=5)
    self.conv2 = nn.Conv2d(32, 64, kernel_size=5)
    self.conv3 = nn.Conv2d(64,128, kernel_size=5)

    self.fc1 = nn.Linear(128*9*9,512)
    self.fc2 = nn.Linear(512, 2)

  def forward(self,x):

        x = F.max_pool2d(F.relu(self.conv1(x)), (2,2))

        x = F.max_pool2d(F.relu(self.conv2(x)), (2,2))

        x = F.max_pool2d(F.relu(self.conv3(x)), (2,2))

        x = torch.flatten(x,1)

        x = F.relu(self.fc1(x))

        x = self.fc2(x)



        x = F.softmax(x)  # Apply softmax along the class dimension (dim=1)




        return(x)

train_X = torch.Tensor( [item[0] for item in train_data]  )
train_X = train_X / 255

# one-hot vector labels tensor
train_y = torch.Tensor( [item[1] for item in train_data]  )


net = Net()


optimizer = torch.optim.Adam(net.parameters(), lr=0.001)

loss_function = nn.MSELoss()


batch_size = 16


epochs = 15

for epoch in range(epochs):
    epoch_loss = 0.0
    correct = 0
    total = 0

    for i in range(0,len(train_X), batch_size):

        print(f"EPOCH {epoch+1}, fraction complete: {i/len(train_X)}")

        batch_X = train_X[i: i+batch_size].view(-1, 1,  100, 100)
        batch_y = train_y[i: i+batch_size]

        optimizer.zero_grad()

        outputs = net(batch_X)


        loss = loss_function(outputs,batch_y)

        loss.backward()


        optimizer.step()

         # Accumulate the loss (using .item() to extract the scalar value)
        epoch_loss += loss.item()

        # Assuming outputs are raw scores (logits), get predicted class indices
        predicted = outputs.argmax(dim=1)
        correct += (predicted == batch_y.argmax(dim=1)).sum().item()
        total += batch_y.size(0)

    # Compute average loss and accuracy over the epoch
    avg_loss = epoch_loss / (len(train_X) / batch_size)
    accuracy = correct / total

    print(f"Epoch {epoch+1} complete: Avg Loss: {avg_loss:.4f}, Accuracy: {accuracy:.4f}")






torch.save(net.state_dict(), "saved_model.pth")

#testing

net = Net()
net.load_state_dict(torch.load('saved_model.pth'))
net.eval()

#change to tensor objects
test_X = torch.Tensor( [item[0] for item in test_data]  )
test_X = test_X / 255

# one-hot vector labels tensor
test_y = torch.Tensor( [item[1] for item in test_data]  )



correct = 0
total = 0


with torch.no_grad():

    for i in range(len(test_X)):

        output = net(test_X[i].view(-1, 1, 100, 100))[0]

        if output[0] >= output[1]:
            guess = "Benign"
        else:
            guess = "Malignant"

        real_label = test_y[i]

        if real_label[0] >= output[1]:
            real_class = "Benign"
        else:
            real_class = "Malignant"

        if guess == real_class:
            correct += 1

        total += 1


print(f"Accuracy: {round(correct/total,10)}")
